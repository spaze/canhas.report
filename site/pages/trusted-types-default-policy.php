<?php
declare(strict_types = 1);

$cspHeader = "Content-Security-Policy: require-trusted-types-for 'script'; report-uri " . \Can\Has\reportUrl('csp/enforce');
header($cspHeader);
?>
<!DOCTYPE html>
<html lang="en">
<?= \Can\Has\pageHead('Require Trusted Types with CSP'); ?>
<body>
<?= \Can\Has\headerHtml('DOM-XSS Prevention with Trusted Types and CSPRO'); ?>
<div id="main">
<div class="content">
	<?= \Can\Has\bookmarks('index', 'reports'); ?>
	<h1>Prevent DOM-based XSS with Trusted Types and Content Security Policy with <code>report-uri</code></h1>
	<p><em>
		Once Trusted Types are enabled, then when a plain string is being passed to a so-called sink like the <code>innerHTML</code> or the <code>document.write()</code> method without it being escaped by the Trusted Types policy, a report is generated by the browser.
		The string will not actually be passed to the sink, if the policy is enforced. This will protect your app against <abbr title="Document Object Model">DOM</abbr>-based cross-site scripting (<abbr title="Cross-Site Scripting">XSS</abbr>) attacks.
	</em></p>
	<p><em>
		However, you may need to update your application to call the <code>policy.createHTML()</code> method when assigning data to a sink like the <code>innerHTML</code> property.
		But you can also create a policy called <code>default</code>, which will be automatically called whenever a string is used in a sink that only accepts Trusted Types.
	</em></p>
	<?= \Can\Has\trustedTypesNotSupportedHtml(); ?>
	<h2>The CSP response header:</h2>
	<pre><code><?= \Can\Has\highlight($cspHeader); ?></code></pre>

	<h2>Trusted Types with a default policy</h2>
	<p>
		<button id="prompt-html" class="schroedingers-cat">Enter any HTML</button>
		<code class="allowed">#html</code> sink: <code id="html">&hellip;</code>
		<?php \Can\Has\scriptSourceHtmlStart('schroedingers-cat'); ?>
		<script>
			trustedTypes.createPolicy('default', {
				createHTML: string => string.replaceAll('<', '&lt;'),
			});
			document.getElementById('prompt-html').onclick = function() {
				const html = prompt('Enter any HTML', 'foo <strong>bar</strong>');
				if (html) {
					document.getElementById('html').innerHTML = html;
				}
			}
		</script>
		<?php \Can\Has\scriptSourceHtmlEnd(); ?>
	</p>
	The <code class="allowed">#html</code> sink:
	<ul>
		<li>Is <span class="allowed">allowed</span> in a way that it will display the HTML you've entered, automatically escaped by the default policy</li>
		<li>
			Behind the scenes, it uses the <code>createHTML()</code> method of the <code>default</code> policy created by <code>trustedTypes.createPolicy()</code>
			<ul>
				<li>&hellip; to replace all <code>&lt;</code> (&quot;less than&quot;) characters with <code>&amp;lt;</code> entity, a very simple and naive escaping function</li>
			</ul>
		</li>
		<li>
			If you enter let's say <code>&lt;em&gt;</code>, this is what happens automatically, behind the scenes:
			<ul>
				<li><code>createHTML()</code> will convert it to <code>&amp;lt;em&gt;</code></li>
				<li>Wrap it in a <code>TrustedHTML</code> object</li>
				<li>And pass it to the <code>innerHTML</code> sink</li>
			</ul>
		<li>Note that your browser, not the policy, will convert <code>&gt;</code> to <code>&amp;gt;</code> as well, so in Developer Tools you will see <code>&amp;lt;em&amp;gt;</code></li>
	</ul>

	<?= \Can\Has\specsHtml('trusted-types'); ?>
</div>
</div>
<?= \Can\Has\footerHtml(); ?>
</body>
</html>
